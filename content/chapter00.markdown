### Chapter 0

### 操作系统接口

操作系统的工作是将一台计算机的资源在多个进程间共享，并且提供一系列比硬件驱动更有用的服务。操作系统管理并且抽象底层硬件，因此一个文字处理软件不用去关心自己使用的是何种硬盘。操作系统同样多路复用这些硬件，使得多个程序可以同时运行（或看上去同时运行）。最后，操作系统给程序与程序间提供一种可控的交流方式，使得程序之间可以共享数据、共同工作。

一个操作系统通过某种接口向用户程序提供服务。设计一个好的接口非常困难，一方面我们希望接口设计得尽可能短小精悍，因为这使得实现它更加轻松；另一方面我们希望能够给应用程序提供一些精巧复杂的功能。解决这种矛盾的办法是设计尽可能少的**机制**，通过这些机制的组合提供强大、通用的接口。

这本书通过一个独立的操作系统作为实例来阐述操作系统的概念，xv6操作系统提供 Ken Thompson 和 Dennis Richie 在 Unix 操作系统中引入的基本接口，同时模仿 Unix 的内部设计。Unix 提供一个很简单的接口，但他们的恰当搭配能够组合出惊人的通用性。这样的接口非常成功，使得包括 BSD，Linux，Mac OS X，Solaris （甚至在某种程度上 Microsoft）都有类 Unix 的接口。理解 xv6 是理解这些操作系统的一个良好起点。

如图0-1所示，xv6 使用了传统的内核概念 - 一个特殊的向其他运行中程序提供服务的程序。每一个运行中程序（称之为进程），有一片包含指令、数据、栈的内存空间。指令实现了程序的运算，数据是运算的载体，栈管理了程序的过程调用。

内核使用了 CPU 的硬件保护机制来保证一个用户进程都只能访问自己的内存空间。内核拥有实现保护机制所需的硬件特权(hardware privileges)，而用户程序没有这些权限。当一个用户程序进行一次系统调用时，硬件提升了特权级并且开始执行一些内核中预定义的功能。

内核提供的一套系统调用就是用户程序可见的操作系统接口，xv6 操作系统提供了 Unix 内核传统系统调用的一部分，它们是：

---
| 系统调用| 描述|
|--------|
|fork() | 创建进程|
|exit() | 结束当前进程
|wait() | 等待子进程结束
|kill(pid) | 结束 pid 所指进程
|getpid()| 获得当前进程 pid
|sleep(n)| 睡眠 n 秒
|exec(filename, *argv)| 加载并执行一个文件
|sbrk(n)| 增加进程 n 字节的用户进程内存空间
|open(filename, flags)| 打开文件，flags 指定读/写模式
|read(fd, buf, n)| 从文件中读 n 个字节到 buf
|write(fd, buf, n)| 从 buf 中写 n 个字节到文件
|close(fd)| 关闭打开的 fd
|dup(fd)| 复制 fd
|pipe( p)| 创建通道，从 p 反悔读和写的 fd
|chdir(dirname)| 改变当前目录
|mkdir(dirname)| 创建文件夹
|mknod(name, major, minor)| 创建设备文件
|fstat(fd)| 返回文件信息
|link(f1, f2)| 给 f1 创建一个新名字(f2)
|unlink(filename)| 删除文件

这一章剩下的部分将勾勒 xv6 提供服务的概貌 —— 进程，内存，文件描述符，通道和文件系统，为了描述他们，我们给出了代码段和一些附加的讨论。这些系统调用在 shell 上的应用阐述了他们的设计是多么独具匠心。

Shell 是一个普通的程序，它接受用户输入的命令并且执行它们，它也是传统 Unix 系统中最基本的用户界面。Shell 是一个普通程序，而不是内核的一部分，充分说明了系统调用接口的强大，强大得似的 Shell 没有任何的不同之处。这也意味着 shell 是很容易被替代的，实际上这导致了咸蛋 Unix 系统有着各种各样的 shell，每一个都有着自己的用户界面和脚本特性。xv6 shell 本质上是一个 Unix Bourne shell 的简单实现。它的实现在第 7850 行。

#### 进程和内存

一个 xv6 进程由两部分组成，一部分是用户内存空间（指令，数据，栈），另一部分是仅对内核可见的进程状态。xv6 提供了分时特性：它在可用 CPU 之间不断切换，决定哪一个等待中的进程被执行。当一个进程不在执行时，xv6 报错它的 CPU 寄存器，当他们再次被执行时恢复这些寄存器的值。内核将每个进程和一个 pid 关联起来。

一个进程可以调用系统调用 fork 来创建一个新的进程。`fork` 创建的新进程成为子进程，子进程的内存中的内容同创建它的进程（父进程）一样。`fork` 函数在父进程、子进程中都返回（一次调用两次返回）。对于父进程它返回子进程的 pid，对于子进程它返回0。考虑下面这段代码：

```
int pid;     pid = fork();     if(pid > 0){       printf("parent: child=%d\n", pid);       pid = wait();       printf("child %d is done\n", pid);     } else if(pid == 0){       printf("child: exiting\n");       exit();     } else {       printf("fork error\n");}
```
系统调用 exit 会导致调用它的进程停止运行，并且释放诸如内存和打开文件在内的资源。系统调用 wait 会返回一个一个已经退出了的当前进程的子进程，如果没有子进程退出，wait 会等候直到有一个子进程退出。在上面的例子中，下面的输出
```
parent: child=1234
child: exiting
```
可能以任意顺序打印