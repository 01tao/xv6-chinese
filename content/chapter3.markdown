### Chapter 3

### 陷入，中断和驱动

运行进程时，cpu 一直处于一个大循环中：取指，更新 PC，执行，反复……。但有些情况下用户程序的控制必须转移回内核，而不是执行下一条指令。这些情况包括设备信号、用户程序的非法操作（引用一个没有 PTE 的虚拟地址）。处理这些事件有三大挑战：1）内核必须使得处理器从用户态转换到内核态（并且再转换回用户态）2）内核的设备必须协调好他们并行的活动。3）内核必须非常清楚硬件接口。解决这三个问题需要对硬件的深入理解和小心翼翼的编程，并且有可能导致不透明的内核代码。这一章告诉你 xv6 是如何解决这些问题的。

#### 系统调用，异常和中断

用户程序通过系统调用请求系统服务，正如我们上一章最后所见。术语`exception`指产生中断的非法程序操作，例如除以0，尝试访问 PTE 不存在的内存等等。术语`interrupt`指硬件产生的希望引起操作系统注意的信号，例如时钟芯片可能每100毫秒产生一个中断，利用此来实现分时。再举一个例子，当硬盘从硬盘读了一个块时，它产生一个中断来提醒操作系统这个块已经准备好被获取了。

内核管理所有的中断，而不是进程，因为在大多数情况下只有内核拥有所需的特权和状态。例如为了使进程响应时钟中断而在进程间实现时间切片，就必须在内核中执行这些操作，因为我们有可能强迫不协调的进程服从处理器的调度。

在所有三种情况下，操作系统的设计必须保证下面这些事情。系统必须保存寄存器以备将来的状态恢复。系统必须准备好在内核中执行，必须选择一个内核开始执行的地方。内核必须能够获得关于这个事件的信息，例如系统调用的参数。同时还必须保证安全性；系统必须保持用户进程和系统进程的隔离。

为了大成这个目标操作系统必须知道硬件是如何处理系统调用、异常和中断的。在大多数处理器中这三种事件都用同样的硬件机制处理。比如说，在 x86中，一个程序可以通过int 指令看上一个中断来进行系统调用。同样的，异常也会产生一个中断。因此，如果操作系统设计了中断处理，那么操作系统也可以处理系统调用以及异常。

我们的计划是这样的。中断终止正常的处理器循环然后开始执行中断处理程序中的代码。在开始中断处理程序之前，处理器保存他的寄存器，这样在操作系统从终端中返回式就可以恢复他们。和中断服务程序之间的来回面临的问题是处理器需要在用户模式和内核模式之间来回切换。

咱们说说术语：虽然官方的 x86 术语是中断，xv6 都用陷入来代表他们，很大程度上是因为这个术语被 PDP11/40 使用，从而我也是传统的 Unix 术语。这一章交替使用陷入和中断这两个术语，但一定要记住陷入是由 在 cpu 上运行的当前进程导致的，而中断是有设备导致的，可能与当前进程毫无关系。比如说，磁盘可能在接受了一个进程的数据块之后发出一个中断，但是在中断的时候可能运行的是其他进程。中断的这一特性似的思考中断的相关问题比陷入要难，因为中断和其它活动是并行的。然而正如我们马上就要讨论的，他们都依赖相同的硬件机制在用户模式和内核模式之间进行切换。

### X86 的保护机制

x86 有四个特权级，从 0（特权最高）编号边号到 3（特权最低）。在实际使用中，大多数的操作系统都是使用两个特权级，0 和 3，他们被称为内核模式和用户模式。当前执行指令的特权级存在于 %cs 寄存器中的域 CPL 中。

在 x86 中，中断处理程序在终端描述符表（IDT）中被定义。这个表有 256 个表项，每一个都提供了响应相应中断的 %cs 和 %eip。

一个程序要在 x86 上进行一个系统调用，它需要调用 int n 指令，这里 n 就是 IDT 的索引。int 指令进行下面一些步骤：

* 从 IDT 中获得第 n 个描述符，n 就是 int 的参数。
* 检查 %cs 的域 CPL <= DPL，DPL 是描述符中记录的特权级。
* 如果目标段选择符的 PL < CPL，就在 CPU 内部的寄存器中保存 %esp 和 %ss 的值。
* 从一个任务段描述符中加载 %ss 和 %esp。
* 将 %ss 压栈。
* 将 %esp 压栈。
* 将 %eflags 压栈。
% 将 %cs 压栈。
* 将 %eip 压栈。
% 清除 %eflags 的一些位。
* 设置 %cs 和 %eip 为描述符中的值。

int 指令是一个非常复杂的指令，可能有人会问是不是所有的这些操作都是必要的。检查 CPL <= DPL 是的内核可以禁止一些特权级系统调用。例如，如果用户成功执行了 int 指令，那么 DPL 必须是 3.如果用户程序没有合适的特权级，那么int 指令就会导致 int 13，这是一个通用保护错误。再举一个例子，int 指令不能使用用户栈来保存值，因为用户可能还没有建立一个合适的栈，因此硬件会使用任务段中指定的栈（这个栈在内核模式中建立）。

![figure3-1](../pic/f3-1.png)

图 3-1 展示了一个 int 指令之后（发生了特权级转换，即描述符中的特权级比 CPL 中的低）的栈的情况，如果这条指令没有导致一个特权级转换，x86不会保存 %ss 和 %esp。在任何一种情况下，%eip 都指向描述符表中指定的地址，这个地址的第一条指令就是将要执行的下一条指令，也是 int n 的中断处理程序的第一条指令。操作系统应该实现这些中断处理程序，下面我们来看看 xv6 干了些什么。

操作系统可以使用 iret 指令来从一个 int 指令中返回。它从栈中弹出 int 指令保存的值，然后通过恢复保存的 %eip 的值来继续用户程序的执行。

### 代码：第一个系统调用

第一章的最后在 `initcode.S` 中调用了一个系统调用。让我们再看一遍（7713）。这个进程将 `exec` 所需的参数压栈，然后把系统调用号存在 %eax 中。这个系统调用号和 syscalls 数组中的条目匹（syscall 是一个函数指针的数组（3350）。我们需要设法使得 int 指令强处理器的状态从用户模式切换到内核模式，从而内核能调用正确的内核函数（例如我 sys_exec），并且可以取出sys_exec的参数。接下来的几个小节将描述 xv6 是如何做到这一点的，我们将会发现我们可以用同样的代码来实现中断和异常。

### 代码：汇编内陷处理程序

xv6 必须设置硬件在遇到 int 指令时进行一些特殊的操作，这些操作会使处理器产生一个中断。x86允许256个不同的中断。中断0-31被定义为软件中断，比如除0错误和访问非法的内存页。xv6 将终端号 32-63 映射给硬件中断，并且使用 64 作为系统调用的中断号。

`Tvinit` (3076) 在 main 中被调用，它设置了 idt 表中的 256 个表项。中断 i 被位于 vectors[i] 的代码处理。每一个中断处理程序的入口点都是不同的，因为 x86 并未把中断号传递给中断处理程序，使用 256 个不同的处理程序是唯一的区分这 256 种情况的办法。

Tvinit 处理 T_SYSCALL，用户系统会调用 trap，特别地：它通过传递第二个参数 1 来指定门的类型是『trap』。xv6 不运行进程用 int 来产生其他中断（比如设备中断）；如果它们试着这么做了，就会抛出通用保护异常，就会导致中断 13 的发出。

当保护等级从用户模式向内核模式转换时，内核不能使用用户的栈，因为它可能不是有效的。用户进程可能是恶意的或者包含了一些错误，使得用户的 %esp 指向一个不是用户内存的地方。xv6 对 x86 的硬件进行编程使得在内陷的时候回发生一个栈切换，栈切换的方法是让硬件从一个任务段描述符中读出新的栈选择符和一个新的 %esp 的值。函数 switchuvm（1773）把用户进程的内核栈栈顶地址存入任务段描述符中。

当内陷发生时，处理器会做下面一些事。如果处理器正运行在用户模式，它会从段选择符中加载 %esp 和 %ss，把老的用户 %ss 和 %esp 压入新的栈中。如果内核正在内核模式中执行，上面的事件就不会发生。处理器接下来把 %eflags，%cs，%eip 压栈。对于某些内陷来说，处理器只压入一个错误字。而后，处理器从相应 IDT 表项中加载新的 %eip 和 %cs。

xv6 使用一个 perl 脚本（2950）来产生 IDT 表项指向的处理函数入口点。每一个入口都会压入一个错误码（如果 CPU 没有压入的话），压入中断号，然后跳转到 alltraps。

Alltraps（3004）继续保存处理器的寄存器：它压入 %ds


[to be continued]
