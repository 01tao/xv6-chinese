### Chapter 3

### 陷入，中断和驱动

运行进程时，cpu 一直处于一个大循环中：取指，更新 PC，执行，反复……。但有些情况下用户程序的控制必须转移回内核，而不是执行下一条指令。这些情况包括设备信号、用户程序的非法操作（引用一个没有 PTE 的虚拟地址）。处理这些事件有三大挑战：1）内核必须使得处理器从用户态转换到内核态（并且再转换回用户态）2）内核的设备必须协调好他们并行的活动。3）内核必须非常清楚硬件接口。解决这三个问题需要对硬件的深入理解和小心翼翼的编程，并且有可能导致不透明的内核代码。这一章告诉你 xv6 是如何解决这些问题的。

#### 系统调用，异常和中断

用户程序通过系统调用请求系统服务，正如我们上一章最后所见。术语`exception`指产生中断的非法程序操作，例如除以0，尝试访问 PTE 不存在的内存等等。术语`interrupt`指硬件产生的希望引起操作系统注意的信号，例如时钟芯片可能每100毫秒产生一个中断，利用此来实现分时。再举一个例子，当硬盘从硬盘读了一个块时，它产生一个中断来提醒操作系统这个块已经准备好被获取了。

内核管理所有的中断，而不是进程，因为在大多数情况下只有内核拥有所需的特权和状态。例如为了使进程响应时钟中断而在进程间实现时间切片，就必须在内核中执行这些操作，因为我们有可能强迫不协调的进程服从处理器的调度。

在所有三种情况下，操作系统的设计必须保证下面这些事情。系统必须保存寄存器以备将来的状态恢复。系统必须准备好在内核中执行，必须选择一个内核开始执行的地方。内核必须能够获得关于这个事件的信息，例如系统调用的参数。同时还必须保证安全性；系统必须保持用户进程和系统进程的隔离。

为了大成这个目标操作系统必须知道硬件是如何处理系统调用、异常和中断的。在大多数处理器中这三种事件都用同样的硬件机制处理。比如说，在 x86中，一个程序可以通过int 指令看上一个中断来进行系统调用。同样的，异常也会产生一个中断。因此，如果操作系统设计了中断处理，那么操作系统也可以处理系统调用以及异常。

我们的计划是这样的。中断终止正常的处理器循环然后开始执行中断处理程序中的代码。在开始中断处理程序之前，处理器保存他的寄存器，这样在操作系统从终端中返回式就可以恢复他们。和中断服务程序之间的来回面临的问题是处理器需要在用户模式和内核模式之间来回切换。

咱们说说术语：虽然官方的 x86 术语是中断，xv6 都用陷入来代表他们，很大程度上是因为这个术语被 PDP11/40 使用，从而我也是传统的 Unix 术语。这一章交替使用陷入和中断这两个术语，但一定要记住陷入是由 在 cpu 上运行的当前进程导致的，而中断是有设备导致的，可能与当前进程毫无关系。比如说，磁盘可能在接受了一个进程的数据块之后发出一个中断，但是在中断的时候可能运行的是其他进程。中断的这一特性似的思考中断的相关问题比陷入要难，因为中断和其它活动是并行的。然而正如我们马上就要讨论的，他们都依赖相同的硬件机制在用户模式和内核模式之间进行切换。

### X86 的保护机制

x86 有四个特权级，从 0（特权最高）编号边号到 3（特权最低）。在实际使用中，大多数的操作系统都是使用两个特权级，0 和 3，他们被称为内核模式和用户模式。当前执行指令的特权级存在于 %cs 寄存器中的域 CPL 中。

在 x86 中，中断处理程序在终端描述符表（IDT）中被定义。这个表有 256 个表项，每一个都提供了响应相应中断的 %cs 和 %eip。

一个程序要在 x86 上进行一个系统调用，它需要调用 int n 指令，这里 n 就是 IDT 的索引。int 指令进行下面一些步骤：

* 从 IDT 中获得第 n 个描述符，n 就是 int 的参数。
* 检查 %cs 的域 CPL <= DPL，DPL 是描述符中记录的特权级。
* 如果目标段选择符的 PL < CPL，就在 CPU 内部的寄存器中保存 %esp 和 %ss 的值。
* 从一个任务段描述符中加载 %ss 和 %esp。
* 将 %ss 压栈。
* 将 %esp 压栈。
* 将 %eflags 压栈。
% 将 %cs 压栈。
* 将 %eip 压栈。
% 清除 %eflags 的一些位。
* 设置 %cs 和 %eip 为描述符中的值。

int 指令是一个非常复杂的指令，可能有人会问是不是所有的这些操作都是必要的。检查 CPL <= DPL 是的内核可以禁止一些特权级系统调用。例如，如果用户成功执行了 int 指令，那么 DPL 必须是 3.如果用户程序没有合适的特权级，那么int 指令就会导致 int 13，这是一个通用保护错误。再举一个例子，int 指令不能使用用户栈来保存值，因为用户可能还没有建立一个合适的栈，因此硬件会使用任务段中指定的栈（这个栈在内核模式中建立）。

![figure3-1](../pic/f3-1.png)

图 3-1 展示了一个 int 指令之后（发生了特权级转换，即描述符中的特权级比 CPL 中的低）的栈的情况，如果这条指令没有导致一个特权级转换，x86不会保存 %ss 和 %esp。在任何一种情况下，%eip 都指向描述符表中指定的地址，这个地址的第一条指令就是将要执行的下一条指令，也是 int n 的中断处理程序的第一条指令。操作系统应该实现这些中断处理程序，下面我们来看看 xv6 干了些什么。

操作系统可以使用 iret 指令来从一个 int 指令中返回。它从栈中弹出 int 指令保存的值，然后通过恢复保存的 %eip 的值来继续用户程序的执行。

### 代码：第一个系统调用

第一章的最后在 `initcode.S` 中调用了一个系统调用。让我们再看一遍（7713）。这个进程将 `exec` 所需的参数压栈，然后把系统调用号存在 %eax 中。这个系统调用号和 syscalls 数组中的条目匹（syscall 是一个函数指针的数组（3350）。我们需要设法使得 int 指令强处理器的状态从用户模式切换到内核模式，从而内核能调用正确的内核函数（例如我 sys_exec），并且可以取出sys_exec的参数。接下来的几个小节将描述 xv6 是如何做到这一点的，我们将会发现我们可以用同样的代码来实现中断和异常。

### 代码：汇编内陷处理程序

xv6 必须设置硬件在遇到 int 指令时进行一些特殊的操作，这些操作会使处理器产生一个中断。x86允许256个不同的中断。中断0-31被定义为软件中断，比如除0错误和访问非法的内存页。xv6 将终端号 32-63 映射给硬件中断，并且使用 64 作为系统调用的中断号。

`Tvinit` (3076) 在 main 中被调用，它设置了 idt 表中的 256 个表项。中断 i 被位于 vectors[i] 的代码处理。每一个中断处理程序的入口点都是不同的，因为 x86 并未把中断号传递给中断处理程序，使用 256 个不同的处理程序是唯一的区分这 256 种情况的办法。

Tvinit 处理 T_SYSCALL，用户系统会调用 trap，特别地：它通过传递第二个参数 1 来指定门的类型是『trap』。xv6 不运行进程用 int 来产生其他中断（比如设备中断）；如果它们试着这么做了，就会抛出通用保护异常，就会导致中断 13 的发出。

当保护等级从用户模式向内核模式转换时，内核不能使用用户的栈，因为它可能不是有效的。用户进程可能是恶意的或者包含了一些错误，使得用户的 %esp 指向一个不是用户内存的地方。xv6 对 x86 的硬件进行编程使得在内陷的时候回发生一个栈切换，栈切换的方法是让硬件从一个任务段描述符中读出新的栈选择符和一个新的 %esp 的值。函数 switchuvm（1773）把用户进程的内核栈栈顶地址存入任务段描述符中。

当内陷发生时，处理器会做下面一些事。如果处理器正运行在用户模式，它会从段选择符中加载 %esp 和 %ss，把老的用户 %ss 和 %esp 压入新的栈中。如果内核正在内核模式中执行，上面的事件就不会发生。处理器接下来把 %eflags，%cs，%eip 压栈。对于某些内陷来说，处理器只压入一个错误字。而后，处理器从相应 IDT 表项中加载新的 %eip 和 %cs。

xv6 使用一个 perl 脚本（2950）来产生 IDT 表项指向的处理函数入口点。每一个入口都会压入一个错误码（如果 CPU 没有压入的话），压入中断号，然后跳转到 alltraps。

Alltraps（3004）继续保存处理器的寄存器：它压入 %ds, %es, %fs, %gs, 以及通用寄存器（3005-3010)。这么做的结果是现在的内核栈就产生一个 `trapframe`（中断帧） 结构体，这个结构体包含了中断发生时的处理器寄存器状态（参见图3-2）。处理器接着又压入 %ss，%esp，%eflags，%cs 和 %eip。处理器或者中断向量会压入一个错误码，而`alltraps`压入剩余的。中断帧包含了所有处理器从当前进程的内核态恢复到用户态需要的信息，所以处理器可以恰如中断开始时那样继续执行。回顾一下第二章，`userinit`手动建立了一个中断帧来达到这个目标（参见图1-3）。

考虑第一个系统调用这个场景，被保存的 %eip 是 int 指令下一条指令的 地址。%cs 是用户代码段选择符。%eflags 是执行 int 指令时的 eflags 寄存器，`alltraps` 同时也保存 %eax，它存有系统调用号，内核在之后会使用到它。

现在用户态的寄存器都保存了，`alltraps` 可以完成对处理器的设置并开始执行内核的C代码。处理器在进入中断处理程序之前设置选择符 %cs 和 %ss；`alltraps` 设置 %ds 和 %es（3013-3015）。它设置 %fs 和 %gs 来指向 SEG_KCPU（每 CPU 数据段）（3016-3018）。

一旦段设置好了，`alltraps` 就可以调用 C 中端处理程序 `trap`。它压入 %esp 作为 `trap` 的参数，%esp 指向刚在栈上建立好的中断帧（3021）。然后它调用 `trap`（3022）。trap 返回后，alltraps 弹出栈上的参数（3023）然后执行标号为 trapret 处的代码。我们在第二章阐述第一个用户进程的时候跟踪分析了这段代码，在那里第一个用户进程通过执行 trapret 处的代码来退出到用户空间。同样地事情在这里也发生：弹出中断帧会恢复用户模式下的寄存器，然后执行 iret 会跳回到用户空间。

现在的讨论谈到了发生在用户模式下地中断，但是中断也可能发生在内核模式下。在那种情况下硬件不需要进行栈转换，也不需要保存栈指针或栈段选择符；除此之外的别的步骤都和发生在用户模式下的中断一样，执行的 xv6 中断处理程序的代码也是一样的。当 iret 恢复了一个内核模式下地 %cs，处理器会机修在内核模式下执行。

### 代码：C 中断处理程序

我们在上一节中看到每一个处理程序简历一个中断帧然后调用C函数 trap。trap（3101）查看硬件中断号 tf->trapno 来决定自己为什么被调用以及应该做些什么。如果中断是 T_SYSCALL，trap 调用系统调用处理程序 syscall。我们会在第五章再来讨论这里的两个 cp->killed 检查。

当查询完系统调用，trap 查询是否是硬件中断（我们会在下面讨论）。中断可能来自预期的硬件设备，也可能来自异常的、未预料到得硬件中断。

如果中断不是一个系统调用也不是一个硬件主动引发的中断，trap 就认为它是一个发生中断前的一段代码中的错误行为导致的中断（如除零错误）。如果产生中断的代码来自用户程序，xv6 就打印错误细节并且设置 cp->killed 使之待会被清除掉。我们会在第五章看看xv6是如何做这种清除的。

如果是内核程序正在执行，那就出现了一个内核错误：trap 打印错误细节并且调用 panic。

### 代码：系统调用

对于系统调用，trap 调用 syscall（3375）。syscall 从中断帧中读出系统调用号，中断帧也保存着被保存的%eax，以及到系统调用函数列表的索引。对第一个系统调用而言，%eax 保存的是 SYS_exec（3207），并且 syscall 会调用第 SYS_exec 个系统调用函数表的表项，相应地也就调用了 sys_exec。

syscall 在 %eax 保存系统调用函数的返回值。当 trap 返回用户空间时，它会从 cp->tf 中加载其值到机器的寄存器中。因此，当 exec 返回时，它会返回系统调用处理函数返回的返回值（3381）。系统调用按照惯例会在发生错误的时候返回一个负数，成功执行时返回正数。如果系统调用号是非法的，syscall 会打印一行错误并且返回 -1。

之后的章节会讲解具体系统调用的实现。这一章关心的是系统调用的机制。还有一点点的机制没有说到：获得系统调用的参数。工具函数 argint、argptr 和 argstr 获得第 n 个系统调用参数，他们分别获取一个整数，或者指针，或者字符串始址。argint 利用用户空间的 %esp 寄存器定位第 n 个参数：%esp 指向系统调用结束后的返回地址。参数就恰好在 %esp 之上（%esp+4）。因此第 n 个参数就再 %esp+4+4*n。

argint 调用 fetchint 从用户内存地址读取值到 *ip。fetchint 可以简单地将这个地址直接转换成一个指针，因为用户和内核共享同一个页表，但是内核必须检验这个指针的确指向的是用户内存空间的一部分。内核已经设置好了页表硬件来保证本进程无法访问它的局部私有地址以外的内存：如果一个用户尝试度或者写高于（包含）p->sz的地址，处理器会产生一个段中断，这个中断会杀死此进程，正如我们之前所见。但是现在，我们在内核态中执行，用户提供的任何地址都是有权访问的，因此必须要检查这个地址是在 p->sz 之下的。

argptr 和 argint 的目标是相似的：它解析第 n 个系统调用参数。argptr 调用 argint 来把第 n 个参数当做是整数来获取，然后检查把这个整数看做指针它的确指向的是用户的地址空间。注意 argptr 的源码中有两次检查。首先，用户的栈指针在获取参数的时候被检查。然后这个获取到得参数作为用户指针又经过了一次检查。

argstr 是最后一个用于获取喜用调用参数的函数。它解析第 n 个系统调用参数为指针。它确保这个指针是一个 NUL 结尾的字符串并且整个完整地字符串是在用户地址空间中的。

系统调用的实现（例如，sysproc.c 和 sysfile.c）仅仅是封装而已：他们用 argint，argptr和argstr来解析参数，然后调用真正的实现。在第二章，sys_exec 利用这些函数来获取自己的参数。

### 代码：中断

主板上的设备可以产生中断，xv6 必须配置好硬件来处理这些中断。没有硬件的支持 xv6 不可能正常使用起来：用户不能够用键盘输入，没有一个能够存储数据的文件系统等等。幸运的是，添加一些简单设备的中断并不会增加太多额外的复杂性。正如我们将会见到的，中断可以使用系统调用和异常处理相同的代码。

中断和系统调用相似，除了它可以在任何时候产生。主板上有硬件能够在设备需要的时候向 CPU 发出信号（例如用户在键盘上输入了一个字符）。我们得对设备编程来产生一个中断，然后令 CPU 接受它们的中断。

我们来看一看分时硬件和时钟中断。我们希望分时硬件大约每秒100次的速度产生一个中断，这样内核就可以跟踪到时间的很小一片从而可以在多个运行中的进程间进行分时。100次每秒的速度足以提供良好的交互性能并且同时不会使处理器陷入不断的中断处理中。

像 x86 处理器一样，PC 主板也在进步，并且提供中断的方式也在进步。早期的主板有一个简单地可编程中断控制器（被称作PIC），你可以在 picirq.c 中找到管理它的代码。

随着多核处理器主板的出现，需要一种新的处理中断的方式，因为每一颗CPU都需要一个中断控制器来处理发送给它的中断，而且也得有一个方法来分发中断。这一方式包括两个部分：第一个部分是在 I/O 系统中的（IO APIC，ioapic.c），另一部分是关联在每一个处理器上的（局部 APIC，lapic.c）。xv6 是为搭载多核处理器的主板设计的，每一个处理器都需要编程接受中断。

为了在单核处理器上也能够正常运行，xv6 也为 PIC 编程（6932）。每一个 PIC 可以处理最多 8 个中断（亦即设备）并且将他们接到处理器的中断引脚上。为了支持多余八个硬件，PIC 可以进行级联，典型的主板至少有两集级联。使用 inb 和 outb 指令，xv6 配置主 PIC 产生 IRQ 0 到 7，从 PIC 产生 IRQ 8 到 16。最初 xv6 配置 PIC 屏蔽所有中断。timer.c 中得代码设置时钟 1 并且使能 PIC 上相应地中断（7574）。这样的描述忽略了编写PIC得一些细节。这些 PIC（也包括IOAPIC和LAPIC）的细节对本书来说并不重要，但是感兴趣的读者可以参考各设备的手册，它们在源代码中有所引用。

在多核处理器上，xv6 必须编写 IOAPIC 和每一个处理器的 LAPIC。IO APIC 维护了一张表，处理器可以通过内存映射的 I/O 编写这个表的表项，而非使用 inb 和 outb 指令。在初始化的过程中，xv6 将第 0 号中断映射到 IRQ 0，以此类推，然后它们都屏蔽掉。不同的设备开启自己的中断，并且指定拿一个处理器接受这个中断。举例来说，xv6 将键盘中断分发到处理器 0（7516）。xv6 将磁盘中断分发到编号最大的处理器，你们将在下面看到。

时钟芯片是在 LAPIC 中的，所以每一个处理器可以独立地接收时钟中断。xv6 在 lapicinit（6651）中设置它。关键的一行代码是 timer（6664）中的代码。

[to be continued]
