## 第六章

### 文件系统

文件系统的目的是组织和存储数据，典型的文件系统支持用户和程序间的数据共享，它也保证数据的持久化——重启之后仍然可用。

xv6的文件系统提供类似 Unix 的文件，文件描述符，目录和路经名（请参阅第零章），并且把数据存储到一块 IDE 磁盘上（请参阅第三章）。这个文件系统解决了几大难题：

* 该文件系统需要在磁盘上的数据结构来表示文件、目录树，这棵树用于标识每个文件用于存储数据的块以及磁盘上哪些区域是空闲的。
* 该文件系统必须支持错误恢复，也就是说，如果系统崩溃了（比如掉电了），文件系统必须在重启后仍能正常工作。问题在于一次系统崩溃可能打断一连串的更新操作，从而使得磁盘上的数据结构变得不一致（例如：有的块同时被标记为被使用和空闲）。
* 不同的进程可能同时操作文件系统，这种并行不能破坏文件系统的正常工作。
* 访问磁盘比访问内存要慢几个数量级，所以文件系统必须要维护一个内存内的 cache 用于缓存常被访问的块。

这一章的剩余内容将阐述 xv6 是如何解决这些问题的。

### 概述

![figure6-1](../pic/f6-1.png)
xv6 文件系统的分6层实现，如图6-1所示。最下面一层通过缓冲器高速缓存读写 IDE 硬盘，它同步了访问磁盘操作，保证同时只有一个内核进程可以修改磁盘块中存有的数据。第二层使得更高的几层可以将对磁盘的更新封装成一次一次的会话，通过会话的方式来保证这些磁盘块的更新操作是原子操作（他们要么都被更新，要么都不被更新）。第三层提供无名文件，每一个这样的文件由一个 inode 和一连串的数据块组成。第四层将目录实现为一种特殊的 inode，它的内容是一连串的目录项，每一个目录项包含一个名字和指向这个名字对应文件的 inode。第五层提供了有层次结构的路经名（如/usr/rtm/xv6/fs.c这样的），这一层通过递归的方式来查询一个路径对应的文件。最后一层将许多 Unix 的资源（如通道，设备，文件等）抽象为文件系统的接口，极大地简化了程序员的工作。

![figure6-2](../pic/f6-2.png)
文件系统必须设计好在磁盘上的什么地方放置 inode 和数据块。xv6把磁盘划分为几个区块，如图6-2所示。文件系统不使用第0块（第0块存有 bootloader）。第一块叫做超级块；它包含了文件系统的元信息（如文件系统的总块数，数据块块数，inode 数，以及 log 的块数）。从第2块开始存放inode，每一块能够存放多个 inode。接下来的块存有用于记录空闲块的位图。剩下的大部分块是数据块，它们存有文件和目录的内容。在磁盘的最后还有 日志块，它们是会话层的一部分，将在后面详述。

### 缓冲器高速缓存层

缓冲器高速缓存（以后简称高速缓存）有两个任务：（1）同步对磁盘的访问，使得同一时间只有一个块在内存中并且只有一个内核进程使用它；（2）缓存常用的块避免它们再从缓慢的磁盘中再读出。代码请参见 bio.c。

高速缓存提供的的主要接口是 bread 和 bwrite；前者从磁盘中取出一块缓存入内存中被读写，后者把内存缓冲区中的一块写到磁盘上正确的地方。当内核处理完一个缓冲块之后，需要调用 brelse 释放它。

高速缓存通过仅允许最多一个内核线程拥有对缓冲块的引用来同步对磁盘的访问，如果一个内核线程拥有一个缓冲快，但还没有释放他，那么其他调用 bread 的进程就会阻塞等待。文件系统的更高几层依赖高速缓存层的同步机制来保证正确性。

高速缓存有固定数量的缓冲区，这意味着如果文件系统请求一个不在缓存中的磁盘块，高速缓存必须换出一个已经放入磁盘快的缓冲区，这里的置换策略是 LRU，假设最近未使用的块不太可能再被使用。

### 代码：缓冲器高速缓存

块高缓是 buffer 的双向链表。 binit 会从一个静态数组 buf 中构建出一个双向链表。所有其他对块高缓的访问都通过链表表头而非静态数组访问。

一个 buffer 有三种状态：B_VALID 意味着这个 buffer 拥有磁盘块的有效内容。B_DIRTY 意味着缓冲区的内容已经被改变并且需要写回磁盘。B_BUSY 意味着有某个内核线程持有这个 buffer 尚未释放。

Bread 调用 bget 从指定的扇区获取一块 buffer。如果 buffer 需要从磁盘中读出，bread 会在返回 buffer 前调用 iderw。

Bget扫描缓冲区列表，来找到给定的设备号和扇区号对应的缓冲区。如果存在这样一个缓冲区，并且它还不是处于 busy 状态，bget 就会设置它的 B_BUSY 标志并且返回。如果找到的缓冲区已经在使用中，bget 就会睡眠并等待它被释放。当 sleep 返回的时候，bget 并不能假设这块缓冲区现在可用了，事实上，sleep 时释放了 buf_table_lock, 醒来后才重新获取了它，这就不能保证 b 仍然是可用的缓冲区：它有可能被用来缓冲另外一个扇区。Bget 非常无奈，只能重新扫描一次，希望这次能够找到可用的缓冲区。

如果 bget 中没有那句 goto 语句的画，那么就可能产生图6-3中的竞争。第一个进程有一块缓冲了扇区3的缓冲区。现在另外两个进程来了，第一个进程 get 缓冲区3 并且它为之开始 sleep。第二个进程 get 换冲区4，并且也可能睡眠在同一块缓冲区上，但这次是在等待新分配的循环中睡眠的，因为已经没有空闲的缓冲区，而持有扇区3的缓冲区处于链表头，因此被选择用于重用。第一个进程释放了这块 buffer，wakeup 恰巧安排进程3先运行，而后它拿到这块 buffer 好把扇区4加载了上去。进程四之后也释放了 buffer 并且唤醒了进程2。如果没有 goto 语句的画，进程2就会标记拿到的 buffer BUSY，从 bget 返回，但实际上这块 buffer 装有扇区4而不是3.这样的错误可能导致各种各样的麻烦，因为扇区3和4的内容是不同的；xv6用它们来存储 inodes。

如果所请求的扇区还未被缓冲，bget 必须分配一个 buffer，可能是重用某一个 buffer。它再次扫描缓冲区列表，寻找一块不是B状态的的块，处于这种状态都快都可以被使用。bgets 修改这个快的元数据来记录新的设备好和扇区号并且标记这个快我为忙碌，最后返回这个我块。需要注意的是，对标记为的复制不仅设置了B_BUSY位，也清除了我B_VALID位的和B_DIRTY位，来的保证 bread 会用磁盘的内容来填充缓冲区，而非是用之前的块的内容。

因为块缓冲是用于同步的，保证任何时候对于每一个扇区都只有一块缓冲区是非常重要的， bgets 第一个循环确认了没有 buffer 已经加载了所需扇区的内容，并且在此之后 bget 都没有释放 buf_table_lock，因此 bgets 的操作是安全的。

如果所有的缓冲区都处于忙碌状态，那么就出问题了，bget 就会报错。一个更有呀的响应是睡眠知道有一块缓冲区变为空闲状态，虽然这有可能导致死锁，一旦 bread 返回了一块缓冲区给自己的调用者，调用者就拥有了对这块缓冲区独有的占用，并且可以对它进行读写操作。如如果调用者写了数据，他必须调用  bwrite 在释放换冲区之前将修改了的数据写入磁盘，Bwrtie 设置 B_DIRTY 位并且调用的 iderw 将缓冲区的内容写到磁盘。

当调用者使用完了一块我缓冲区，他必须调用brelse来释放它，（关于 brelse 这个名字，它是 b-relese 的缩写，它源自 Unix 并且在 BSD，Linux 和 Solaris 中被广泛使用）。Brelse 将一块 buffer 从它当前的位置移动到链表的头部，清除 B_BUSY，唤醒任何睡眠在这块 buffer 上的进程。移动 buffer 的作用在于使得链表按照最近被使用的情况排序，链表中的第一块是最近被用的，最后一块是最早被用的。bget 中的两个循环就利用这一点：寻找已经存在的 buffer 在最坏情况下必须遍历整个链表，但是从最近使用的快开始找（从 bcache.head 开始，然后用 next 指针遍历）会大大减少扫描的时间，如果数据的引用有良好的局部性的话。找到一块可以用于重用的 buffer 就是从链表头向前找，相当于从尾部往头部通过 prev 指针遍历，从而找到的就是最早被使用最近不被使用的块。

### Logging 层

文件系统设计中最有趣的问题就是错误恢复，产生这样的问题是因为大多数的文件系统都涉及到对于磁盘多次的写操作，如果在写操作都过程当中系统崩溃了，就会使得磁盘上的文件系统处于不一致的状态中。举例来说，根据写的顺序的不同，文件上述过程中的错误可能会导致一个目录项指向一个空闲的i节点，或者他可能导致一个已分配但是未被引用的块。后一种情况相对来说好一些，但是一个目录项指向了一个空闲的i节点，再重启之后可能会导致非常严重的问题。

Xv6 通过简单的日志系统来解决文件操作过程当中出现崩溃所导致的问题。一个系统调用并不直接导致对磁盘种文件系统的写操作，想反，他会把一个对磁盘写操作的描述包装成一个日志写在磁盘中。当系统调用把所有的写操作都写好了日志，它就会写一个特殊的 commit 记录到磁盘上，用于指示这份日志包含了一次完整的操作。从那时起，系统调用就会把数据写入磁盘文件系统的数据结构中。在那些写操作都成功完成后，系统调用就会删除磁盘上的日志文件。

为什么日志可以解决文件系统操作中出现的崩溃呢？如果在操作提交之前就蹦溃了，那么磁盘上的日志文件就不会被标记为已完成，恢复系统的代码就会忽视他，磁盘上的状态就好像这个操作从未开始一样。如果实在操作提交之后崩溃的，恢复程序会重演所有的写操作，可能会重复之前已经进行了的对磁盘文件系统的写操作。在任何一种情况下，日志文件都我使得磁盘操作对于系统崩溃来说是原子操作：在恢复之后，要么所有的写操作都完成了，要么没有一个写操作完成。

### 日志设计

日志存在于磁盘最后已知的固定区域。它包含了一个起始块，紧接着一连串的数据块。起始块包含了一个扇区号的数组，没一个扇区写起始块，而不是在提交之前，并且在将日志中的数据块都拷贝到文件系统之后将数据块计数清0。提交之后清0之前的崩溃就会导致一个非0的计数值。

每一个系统调用的代码都指出了必须在从头到尾原子性完成的写操作序列，我们称这样的一个序列为一个会话，虽然他比数据库中的会话要简单得多。任何时候只能有一个进程在一个会话之中，其他进程必须等待当前会话中的进程结束。因此同意时刻日志最多只记录一次会话。

xv6不允许并发会话，目的是为了避免下面几种问题。假设会话 X 把一个对 i节点的修改写入了会话中。并发的会话 Y从同一块中读出了另一个i 节点，更新了它，把 i 节点块写入了日志并且提交。这是一场灾难：Y 的提交导致被 X 修改过的 i 节点块被写入磁盘，而 X 此时并没有提交它的修改。如果这时候发生崩溃会使得 X 的修改只应用了一部分而不是全部，从而打破会话是原子的这一性质。有一些复杂的办法可以解决这样的问题，xv6通过不允许并行的会话来消除这个问题。

xv6允许只读的系统调用能够在一次会话中并发执行。I 节点锁会使得会话对只读系统调用看上去是原子性的。

xv6 使用固定量的磁盘空间来保存日志。系统调用写入日志的块的总大小不能大于日志的总大小。对于大多数系统调用来说这都不是个问题，但是其中两个可能会写大量的块：write 和 unlink。一个大文件的写可能会写很多的数据块、位图块、以及i 节点块。移除个大文件的链接可能会写很多的位图块以及一个 i 节点。XV6的写系统调用将大的写操作拆分成几个小的写操作，使得它们能放入日志中。unlink 不会导致问题因为实际上 xv6 只使用一个位图块。

### 代码：日志

对日志的常见使用方法像下面这样

```
begin_trans();
...
bp = bread(...);
bp->data[...] = ...;
log_write(bp);
```
commit_trans();

begin_trans 会一直等到它获取了对日志的独占使用后返回。

log_write 像是bwrite的一个代理；它把块中新的内容记录到日志中，并且把块的扇区号记录在内存中。log_write 仍将修改后的块留在内存中的块告诉缓冲区中，因此相继的本会话中对这一块的读操作都会返回已修改的内容。log_write 能够知道在一次会话中对同一块进行了多次读写，并且覆盖之前日志中的拷贝。

commit_trans 最开始将日志的起始块写到磁盘上，这样在这个时间点之后的系统崩溃就能够恢复，通过将磁盘中的内容用日志中的内容改写。commit_trans 然后调用 install_trans 来从日志中逐块的读并把他们写到文件系统中合适的地方。最后commit_trans会把日志起始块中的计数改为0，这样在下次会话之前的系统崩溃就会使得恢复代码忽略掉日志。

recover_from_log 在 initlog 中被调用，而 initlog 在第一个用户进程开始前的启动过程中被调用。它读取日志的起始块，如果起始块说日志中有一个提交了的会话，它就会仿照commit_trans的行为执行。

filewrite 中有一个使用了日志的例子：
begin_trans();
ilock(f->ip);
r = writei(f->ip, ...);
iunlock(f->ip);
commit_trans();

这些代码被封装在一个用于将一次大的写操作拆分成一些会话的循环中，在每一次会话中只会写小部分的块，因为日志的大小是有限固定的。对 writei 的调用会在一次会话中写很多的块：文件的i节点，一个或多个位图块，以及一些数据块。begin_trans 之后的 ilock 是一种全局的避免思索的办法：因为在每次会话都已经由一个锁保护了，因此要保持会话开始后锁i节点的顺序。

### 代码：块分配器

文件和目录的内容存在磁盘块中，它们都从一个空闲块池子中分配出来。xv6的块分配器包含一个磁盘上的空闲块位图，每个块占一个比特。这对于引导区，超级快，i节点块和位图块的比特永远都被设置。

块分配器提供两个功能：balloc分配一个新的磁盘块，bfree释放一个块。Balloc最开始调用readsb从磁盘中读出超级块（或者从块缓冲中）到sb中。balloc 会算出哪一块是位图块，计算的方法是记多少块被引导区、超级块和i节点占用（用BBLOCK）。4462行的循环从第0块开始一直到sb.size(文件系统的块总数)。它寻找一个在位图中的位是0的块。效率起见，这个循环被分成两块。外层循环读位图的每一块。内层循环检查这一块中的所有BPB那么多个位。两个进程可能同时申请空闲块，这就有可能导致竞争，但事实上块缓冲只允许一个进程同时只使用一个块。

Bfree找到了空闲的块之后就会清空位图中对应的位。同样，bread和brelse的对块的互斥使用使得无需再特意加锁。

###i节点

i节点这个术语可以有两个意思。它可以指的是磁盘上的记录文件大小、数据块扇区号的数据结构。也可以指内存中的一个i节点，它包含了一个磁盘上i节点的拷贝，以及一些内核需要的附加信息。

所有的磁盘上的i节点都被打包在一个称为i节点块连续的区域中。每一个i节点的大小都是一样的，所以对于一个给定的数字n，很容易找到磁盘上对应的i节点。事实上这个给定的数字就是i节点实现中对它们的编号。

磁盘上的i节点由结构体 dinode 定义。type 域用来区分文件、目录和特殊文件的i节点。如果type是0的话就意味着这是一个空闲的i节点。nlink 域用来记录指向了这一个i节点的目录项，这是用于判断一个i节点是否应该被释放的、。size域记录了文件的字节数。addrs数组用于记录持有这个文件的数据块的块号。

内核把活动的i节点维持在内存中。结构体 inode 是磁盘中的结构体 dinode 在内存中的拷贝。内核只会在有C指针指向一个inode的时候才会把这个inode保存在内存中。ref域用于统计有多少个C指针指向它。如果ref变为0，内核就会丢掉这个i节点。iget和iput两个函数申请和释放i节点指针，修改引用计数。i节点指针可能从文件描述符产生，从当前工作目录产生，也有可能从一些内核代码如exec中产生。

持有iget返回的i节点的指针将保证这个i节点会留在缓存中不会被删掉（特别地不会被用于缓存另一个文件）。因此iget返回的指针是一种比较弱的形式的锁，虽然它并不要求持有者真的锁上这个i节点。文件系统的许多部分都依赖于iget的这个行为，一方面是为了持有长期的对inode的引用（比如打开的文件和当前目录），一方面是在操纵多个i节点的代码中避免竞争同时又防止死锁（比如路径名查找）。

iget 返回的结构体 inode 可能没有任何游泳的内容。为了保证它持有一个磁盘上的inode的有效拷贝，程序必须调用ilock。它会锁住inode（从而其他进程就无法使用它）并且从磁盘中读出inode的信息，如果它还没有被读出的话。iunloc释放inode上的锁。把对inode指针的获取和inode的锁分开避免了某些情况下的思索，比如在目录查询的例子中。数个进程都可以通过iget获得一个inode的C指针，只有一个进程同时可以锁住一个inode。

inode缓存只会缓存内核代码和数据结构使用的C指针指向的inode。它主要的工作是同步多个进程对inode的访问而不是缓存。如果一个inode频繁被使用，块缓冲可能会把它保留在内存中，即使inode缓存没有缓存它。

### 代码：i节点

要申请一个新的i节点（比如创建文件的时候），xv6会调用ialloc。Ialloc同balloc类似：它逐块遍历磁盘上的i节点数据结构，寻找一个标记为空闲的i节点。当它找到一个时，就会把它标记的type修改（变为非0）掉，最后调用iget使得它从inode缓存中返回。

iget遍历inode缓存寻找一个指定设备和i节点号的活动中的项（ip->ref > 0)。如果它找到一项，它就返回对这个inode的新的引用。在iget扫描的时候，它会记录扫描到的第一个空槽，之后如果需要可以用这个空槽来分配一个新的cache项。

调用者在读写inode的元数据或内容之前之前必须用ilock锁住inode。Ilock（4703行）用一个类似的睡眠循环来等待 ip->flag 的I_BUSY位被清除而后由自己再设置它。一旦ilock拥有了对inode的独占，他可以根据需要从磁盘中读取出inode的元数据。函数iunlock清除I_BUSY位并且唤醒睡眠在ilock中的其他进程。

Iput释放指向inode的C指针，实际上就是将引用计数减1.如果减到了0，那么inode缓存中的这个inode槽就会变为空闲状态，并且可以被另一个inode重用。

如果iput发现没有指针指向一个i及诶单并且也没有任何目录项指向它（不在目录中出现的一个文件），那么这个i节点和它关联的数据块都应该被释放。Iput重新锁上这个inode，调用itrunc来把文件截断为0字节，释放掉数据块；把i节点的类型设置为0（unallocated）；把变化写到磁盘中；最后解锁i节点。

iput中对锁的约定值得我们研究。第一个值得研究的地方是当锁上ip的时候，iput简单地认为它会被解锁，而非使用一个睡眠循环。这种情况是正常的，因为调用者被要求在调用iput之前解锁ip，而调用者拥有对它唯一的引用（ip->ref == 1)。第二个值得研究的部分是iput临时释放后又重新获取了缓存的锁。这是必要的因为itrunc和iupdate可能会在磁盘io中睡眠，但是我们必须考虑在没有锁的这段时间都发生了什么。例如，一旦iupdate结束了，磁盘上的数据结构就被标注为可用的，而并发的一个 ialloc 的调用就可能找到它并且重新分配它，而这一切都发生在iput结束之前。Ialloc 会通过调用iget返回对这一块的引用，而iget此时恰好找到了缓存中的ip，但他看见它的I_BUSY位是设置了的，从而睡眠。现在内存中的inode就和磁盘上的不同步了：ialloc重新初始化磁盘上的版本但是需要其他的调用者通过ilock来将它调入内存。为了保证这件事发生，iput必须在释放锁之前把I_BUSY和I_VALID位都清除。它通过4769行的代码把标记为清0.

### 代码：inode内容

磁盘上的inode结构，结构体dinode，记录了大小和数据块的块号数组。inode数据能够在dinode的adddrs数组中被找到。最开始的NDIRECT个块就是这个数组的前NDIRECT个项；这些块被称作直接块。接下来的NINDIRECT个块的数据在inode中列了出来但并没有直接存在inode中，它们存在于一个叫做间接块的数据块中。addrs 数组的最后一项就是间接块的地址。因此一个文件的前6KB（NDIRECT * BSIZE）个自己可以直接从inode中取出，而后64KB（NINDRECT*BSIZE）只能在访问了间接块后取出。这是一个好的磁盘上表示，但对于用户爱说这是比较复杂的一种表示。函数bmap负责这层表示使得高层的像readi和writei这样的接口可以方便书写，我们马上就会看到这一点。Bmap返回inode ip 中的第 bn 个数据块，如果 ip 还没有这样一个数据块，bmap就会分配一个。

函数bmap最开始从最简单的情况开始：前面的NDIRECT个块的数据就在inode中。后面的NINDIRECT个块在ip->addrs[NDIRECT]指向的间接块中。Bmap读出间接块然后再从正确的位置读出一个块号。如果这个块号超出了NDIRECT+NINDRECT，bmap就报错：调用者要负责不访问越界的块号。

Bmap按需分配块。未申请的块用块号0表示。当bmap遇到0的时候，它就把它们替换为新的块号。

Bmap 随着inode的增长按需分配。itrunc释放它们，把inode的大小重新设置为0.Itrunc从直接块开始释放，然后开始释放间接块中列出的块，最后释放间接块本身。

Bmap 使得书写访问i节点数据流的函数变得非常轻松，比如readi和writei。Readi从inode中读出数据。他最开始要保证给定的偏移和读出的量没有超出文件的末尾。从超出文件末尾的地方读会直接返回错误，如果是读的过程当中超出了文件末尾就会返回比请求的数据量少的数据（从读开始的地方到文件末尾的数据，这是所有的能返回的数据）。一个重要的循环处理文件的每一块，从缓冲区中拷贝数据到dst中。函数writei和readi几乎是一样的，只有三个不同：从文件超出文件末尾的地方开始的写或者写的过程中超出文件末尾的话会增长这个文件，直到达到最大的文件大小。这个循环把缓冲区中的内容拷贝到文件而不是拷出来。如果写操作延伸了这个文件，writei必须更新它的大小。

readi和writei最初都会检查ip->type == T_DEV。这是为了处理一些数据不存在于文件系统中的特殊设备；我们会在文件描述符层重新回到这个问题。

函数 stati 把 inode 的元数据拷贝到 stat 结构体中，这个结构体可通过系统调用 stat 暴露给用户程序。

### 代码：目录层

路径名查询会对每一个路径的每一项调用dirlookup。Namei 解析 path 并返回对应的 i 节点。函数 nameiparent 是一个变种；它在最后一个元素之后停止，返回上级目录的inode并且把最后一个元素拷贝到name中。这两个函数都使用namex来实现。

namex最初会计算路径解析从什么地方开始。如果路径以反斜杠开始，解析就会从根目录开始；其他情况下则会从当前目录开始。然后它使用skipelem来依次考虑路径中的每一个部分。每一次循环迭代都必须在当前的i节点ip中找name。循环的开始会把ip锁住，然后检查它的确是一个目录。如果它不是目录的话，查询就宣告失败。（锁住ip是必须的，不是因为ip->type随时有可能变（事实上它不会变），而是因为如果不调用ilock的话，ip->type可能还没有从磁盘中加载出来）。如果是调用nameiparent而且这是最后一个路径元素，那么循环就直接结束了。因为最后一个路径元素已经拷贝到了name中，所以namex只需要返回解锁的ip。最后，循环用dirlookup徐哪找路径元素并且准备下一次的循环（ip=next）。当循环处理了每一个路径元素后，它返回ip。

###文件描述符层

Unix 接口很爽的一点就是大多数的资源都可以用文件来表示，包括终端这样的设备、通道，当然，还有真正的文件。文件描述符层就是实现这种统一性的一层。

Xv6 给每个进程都有一个自己的打开文件表，正如我们在第0章中所见。每一个打开文件都由结构体file表示，它是一个对inode或者pipe和文件偏移的封装。每次调用 open 都会创建一个新的打开文件（一个新的file结构体）。如果多个进程相互独立地打开了同一个文件，不同的实例将拥有不同的 i/o 偏移。另一方面，同一个文件可以（同一个file结构体）可以在一个进程的文件表中多次出现，同时也可以在多个进程的文件表中出现。当一个进程用open打开了一个文件，使用dup，或者把这个文件和子进程共享就会导致这一点发生（注意这不是同一个文件的多个实例，每个实例有不同的偏移。而是同一个文件结构体，相当于同一个指针，这样一个指针在文件表中多次出现）。对每一个打开的文件都有一个引用计数，一个文件可以被打开用于读、或者写或者二者。readable域和writable域记录这一点。

系统中所有的打开文件都存在于一个全局的文件表ftable中。这个文件表有一个分配文件的函数（filealloc），有一个重复引用文件的函数（filedup），释放对文件引用的函数（fileclose），读和写文件的函数（fileread和filewrite）。

前三个的形式我们已经很熟悉了。Filealloc扫面整个文件表来寻找一个没有引用的文件（file->ref == 0)并且返回一个新的引用；filedup增加引用计数；fileclose减少引用计数。当一个文件的引用计数变为0的时候，fileclose就会释放掉当前的pipe或者inode（根据文件类型的不同）。

函数filestat，fileread，filewrite实现了对文件的stat，read，write操作。Filestate只允许作用在i节点上，它通过调用stati实现。Fileread和filewrite检查这个操作被文件的打开属性锁允许然后把执行让渡给inode的实现或者pipe的实现。如果这个文件代表的是一个inode，fileread和filewrite就会把i/o偏移作为该操作的偏移并且往前移。通道没有偏移这个概念。回顾一下inode的函数需要调用者来处理锁。inode锁有一个方便的副作用那就是读写偏移会自动更新，所以同时对一个文件写并不会覆盖各自的文件，但是写的顺序是不被保证的，因此写的结果可能是交织的（比如在一个写操作的过程中插入了另一个写操作）。

### 代码：系统调用

有了底层的这些函数，大多数的系统调用的实现都是很简单的（参见sysfile.c）。还有少数几个调用值得一说。

函数sys_link和sys_unlink修改目录文件，可能会创建或者移除对inode的引用。它们是使用会话的另一个佳例。Sys_link 最开始获取自己的参数，old 和 new 两个字符串。假设old是存在的并且不是一个目录文件，sys_link增加它的ip->nlink计数。然后sys_link调用nameiparent(new)来寻找上级目录和最终的目录元素，并且创建一个目录项指向old的inode。新的上级目录必须和已有的inode在同一个设备上；inode号只在同一个磁盘上有意义。如果这样的错误发生了，sys_link必须回溯并且还原引用计数。

Sys_link 为一个已有的inode创建一个新的名字。函数create为一个新的inode创建新名字。它是三个文件创建系统调用的综合：用O_CREATE标记打开一个文件创建一个新的普通文件，mkdir创一个新的目录文件，mkdev创建一个新的设备文件。就像sys_link一样，create以调用nameiparent开始来获取上级目录的inode。然后它调用dirlookup来检查同名文件是否已经存在。如果的确存在，create的行文就由它服务的系统调用所决定，open和mkdir以及mkdev的语义就不同。 

如果是 open（type==T_FILE）调用的create并且制定的文件名找到的文件是一个普通文件，那么就认为打开成功，所以create中也认为是成功。在其他情况下，这就是一个错误。如果文件名并不存在，create就会用ialloc分配一个新的inode。如果新的inode是一个目录，create就会初始化.和..两个目录项。最后所有的数据都初始化妥当了，create就可以把他连接到他的上级目录。Create，正如sys_link一样，同时拥有两个inode锁：ip和dp。这不可能导致思索因为i节点ip是刚被分配的：系统中没有其他进程会持有ip的锁并且尝试锁dp。

使用create，就能轻易地实现sys_open 和 sys_mkdir，以及 sys_mknod。Sys_open 是最复杂的，因为创建一个新文件只是他能做的很少一部分事。如果open以O_CREATE调用，它就会调用create。否则，它就会调用namei。Create会返回一个带锁的inode，但是namei并不，所以sys_open必须要自己锁上这个inode。这样提供了一个合适的地方来检查目录只被打开用于读，而不是写。假设我们通过各种方法获得了一个inode，sys_open分配了一个文件和文件描述符，接着填充了这个文件。记住没有其他进程能够访问初始化尚未完成的文件，因为他只存在于当前进程的文件表中。

第5章研究了通道的实现，在那时我们甚至还没有一个文件系统。函数sys_pipe通过 pipr 对的方式把pipe的实现连接到文件系统中来。它的参数是一个指向可装入两个整数的数组指针，这个数组将用于记录两个新的文件描述符。然后它分配pipe并且产生新的文件描述符。