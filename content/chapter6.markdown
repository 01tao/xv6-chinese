## 第六章

### 文件系统

文件系统的目的是组织和存储数据，典型的文件系统支持用户和程序间的数据共享，它也保证数据的持久化——重启之后仍然可用。

xv6的文件系统提供类似 Unix 的文件，文件描述符，目录和路经名（请参阅第零章），并且把数据存储到一块 IDE 磁盘上（请参阅第三章）。这个文件系统解决了几大难题：

* 该文件系统需要在磁盘上的数据结构来表示文件、目录树，这棵树用于标识每个文件用于存储数据的块以及磁盘上哪些区域是空闲的。
* 该文件系统必须支持错误恢复，也就是说，如果系统崩溃了（比如掉电了），文件系统必须在重启后仍能正常工作。问题在于一次系统崩溃可能打断一连串的更新操作，从而使得磁盘上的数据结构变得不一致（例如：有的块同时被标记为被使用和空闲）。
* 不同的进程可能同时操作文件系统，这种并行不能破坏文件系统的正常工作。
* 访问磁盘比访问内存要慢几个数量级，所以文件系统必须要维护一个内存内的 cache 用于缓存常被访问的块。

这一章的剩余内容将阐述 xv6 是如何解决这些问题的。

### 概述

![figure6-1](../pic/f6-1.png)
xv6 文件系统的分6层实现，如图6-1所示。最下面一层通过缓冲器高速缓存读写 IDE 硬盘，它同步了访问磁盘操作，保证同时只有一个内核进程可以修改磁盘块中存有的数据。第二层使得更高的几层可以将对磁盘的更新封装成一次一次的会话，通过会话的方式来保证这些磁盘块的更新操作是原子操作（他们要么都被更新，要么都不被更新）。第三层提供无名文件，每一个这样的文件由一个 inode 和一连串的数据块组成。第四层将目录实现为一种特殊的 inode，它的内容是一连串的目录项，每一个目录项包含一个名字和指向这个名字对应文件的 inode。第五层提供了有层次结构的路经名（如/usr/rtm/xv6/fs.c这样的），这一层通过递归的方式来查询一个路径对应的文件。最后一层将许多 Unix 的资源（如通道，设备，文件等）抽象为文件系统的接口，极大地简化了程序员的工作。

![figure6-2](../pic/f6-2.png)
文件系统必须设计好在磁盘上的什么地方放置 inode 和数据块。xv6把磁盘划分为几个区块，如图6-2所示。文件系统不使用第0块（第0块存有 bootloader）。第一块叫做超级块；它包含了文件系统的元信息（如文件系统的总块数，数据块块数，inode 数，以及 log 的块数）。从第2块开始存放inode，每一块能够存放多个 inode。接下来的块存有用于记录空闲块的位图。剩下的大部分块是数据块，它们存有文件和目录的内容。在磁盘的最后还有 日志块，它们是会话层的一部分，将在后面详述。

### 缓冲器高速缓存层

缓冲器高速缓存（以后简称高速缓存）有两个任务：（1）同步对磁盘的访问，使得同一时间只有一个块在内存中并且只有一个内核进程使用它；（2）缓存常用的块避免它们再从缓慢的磁盘中再读出。代码请参见 bio.c。

高速缓存提供的的主要接口是 bread 和 bwrite；前者从磁盘中取出一块缓存入内存中被读写，后者把内存缓冲区中的一块写到磁盘上正确的地方。当内核处理完一个缓冲块之后，需要调用 brelse 释放它。

高速缓存通过仅允许最多一个内核线程拥有对缓冲块的引用来同步对磁盘的访问，如果一个内核线程拥有一个缓冲快，但还没有释放他，那么其他调用 bread 的进程就会阻塞等待。文件系统的更高几层依赖高速缓存层的同步机制来保证正确性。

高速缓存有固定数量的缓冲区，这意味着如果文件系统请求一个不在缓存中的磁盘块，高速缓存必须换出一个已经放入磁盘快的缓冲区，这里的置换策略是 LRU，假设最近未使用的块不太可能再被使用。

### 代码：缓冲器高速缓存

块高缓是 buffer 的双向链表。 binit 会从一个静态数组 buf 中构建出一个双向链表。所有其他对块高缓的访问都通过链表表头而非静态数组访问。

一个 buffer 有三种状态：B_VALID 意味着这个 buffer 拥有磁盘块的有效内容。B_DIRTY 意味着缓冲区的内容已经被改变并且需要写回磁盘。B_BUSY 意味着有某个内核线程持有这个 buffer 尚未释放。

Bread 调用 bget 从指定的扇区获取一块 buffer。如果 buffer 需要从磁盘中读出，bread 会在返回 buffer 前调用 iderw。

Bget扫描缓冲区列表，来找到给定的设备号和扇区号对应的缓冲区。如果存在这样一个缓冲区，并且它还不是处于 busy 状态，bget 就会设置它的 B_BUSY 标志并且返回。如果找到的缓冲区已经在使用中，bget 就会睡眠并等待它被释放。当 sleep 返回的时候，bget 并不能假设这块缓冲区现在可用了，事实上，sleep 时释放了 buf_table_lock, 醒来后才重新获取了它，这就不能保证 b 仍然是可用的缓冲区：它有可能被用来缓冲另外一个扇区。Bget 非常无奈，只能重新扫描一次，希望这次能够找到可用的缓冲区。

如果 bget 中没有那句 goto 语句的画，那么就可能产生图6-3中的竞争。第一个进程有一块缓冲了扇区3的缓冲区。现在另外两个进程来了，第一个进程 get 缓冲区3 并且它为之开始 sleep。第二个进程 get 换冲区4，并且也可能睡眠在同一块缓冲区上，但这次是在等待新分配的循环中睡眠的，因为已经没有空闲的缓冲区，而持有扇区3的缓冲区处于链表头，因此被选择用于重用。第一个进程释放了这块 buffer，wakeup 恰巧安排进程3先运行，而后它拿到这块 buffer 好把扇区4加载了上去。进程四之后也释放了 buffer 并且唤醒了进程2。如果没有 goto 语句的画，进程2就会标记拿到的 buffer BUSY，从 bget 返回，但实际上这块 buffer 装有扇区4而不是3.这样的错误可能导致各种各样的麻烦，因为扇区3和4的内容是不同的；xv6用它们来存储 inodes。

如果所请求的扇区还未被缓冲，bget 必须分配一个 buffer，可能是重用某一个 buffer。它再次扫描缓冲区列表，寻找一块不是B状态的的块，处于这种状态都快都可以被使用。bgets 修改这个快的元数据来记录新的设备好和扇区号并且标记这个快我为忙碌，最后返回这个我块。需要注意的是，对标记为的复制不仅设置了B_BUSY位，也清除了我B_VALID位的和B_DIRTY位，来的保证 bread 会用磁盘的内容来填充缓冲区，而非是用之前的块的内容。

因为块缓冲是用于同步的，保证任何时候对于每一个扇区都只有一块缓冲区是非常重要的， bgets 第一个循环确认了没有 buffer 已经加载了所需扇区的内容，并且在此之后 bget 都没有释放 buf_table_lock，因此 bgets 的操作是安全的。

如果所有的缓冲区都处于忙碌状态，那么就出问题了，bget 就会报错。一个更有呀的响应是睡眠知道有一块缓冲区变为空闲状态，虽然这有可能导致死锁，一旦 bread 返回了一块缓冲区给自己的调用者，调用者就拥有了对这块缓冲区独有的占用，并且可以对它进行读写操作。如如果调用者写了数据，他必须调用  bwrite 在释放换冲区之前将修改了的数据写入磁盘，Bwrtie 设置 B_DIRTY 位并且调用的 iderw 将缓冲区的内容写到磁盘。

当调用者使用完了一块我缓冲区，他必须调用brelse来释放它，（关于 brelse 这个名字，它是 b-relese 的缩写，它源自 Unix 并且在 BSD，Linux 和 Solaris 中被广泛使用）。Brelse 将一块 buffer 从它当前的位置移动到链表的头部，清除 B_BUSY，唤醒任何睡眠在这块 buffer 上的进程。移动 buffer 的作用在于使得链表按照最近被使用的情况排序，链表中的第一块是最近被用的，最后一块是最早被用的。bget 中的两个循环就利用这一点：寻找已经存在的 buffer 在最坏情况下必须遍历整个链表，但是从最近使用的快开始找（从 bcache.head 开始，然后用 next 指针遍历）会大大减少扫描的时间，如果数据的引用有良好的局部性的话。找到一块可以用于重用的 buffer 就是从链表头向前找，相当于从尾部往头部通过 prev 指针遍历，从而找到的就是最早被使用最近不被使用的块。

### Logging 层

文件系统设计中最有趣的问题就是错误恢复，产生这样的问题是因为大多数的文件系统都涉及到对于磁盘多次的写操作，如果在写操作都过程当中系统崩溃了，就会使得磁盘上的文件系统处于不一致的状态中。举例来说，根据写的顺序的不同，文件上述过程中的错误可能会导致一个目录项指向一个空闲的i节点，或者他可能导致一个已分配但是未被引用的块。后一种情况相对来说好一些，但是一个目录项指向了一个空闲的i节点，再重启之后可能会导致非常严重的问题。

Xv6 通过简单的日志系统来解决文件操作过程当中出现崩溃所导致的问题。一个系统调用并不直接导致对磁盘种文件系统的写操作，想反，他会把一个对磁盘写操作的描述包装成一个日志写在磁盘中。当系统调用把所有的写操作都写好了日志，它就会写一个特殊的 commit 记录到磁盘上，用于指示这份日志包含了一次完整的操作。从那时起，系统调用就会把数据写入磁盘文件系统的数据结构中。在那些写操作都成功完成后，系统调用就会删除磁盘上的日志文件。

为什么日志可以解决文件系统操作中出现的崩溃呢？如果在操作提交之前就蹦溃了，那么磁盘上的日志文件就不会被标记为已完成，恢复系统的代码就会忽视他，磁盘上的状态就好像这个操作从未开始一样。如果实在操作提交之后崩溃的，恢复程序会重演所有的写操作，可能会重复之前已经进行了的对磁盘文件系统的写操作。在任何一种情况下，日志文件都我使得磁盘操作对于系统崩溃来说是原子操作：在恢复之后，要么所有的写操作都完成了，要么没有一个写操作完成。

### 日志设计

日志存在于磁盘最后已知的固定区域。它包含了一个起始块，紧接着一连串的数据块。起始块包含了一个扇区号的数组，没一个扇区写起始块，而不是在提交之前，并且在将日志中的数据块都拷贝到文件系统之后将数据块计数清0。提交之后清0之前的崩溃就会导致一个非0的计数值。

每一个系统调用的代码都指出了必须在从头到尾原子性完成的写操作序列，我们称这样的一个序列为一个会话，虽然他比数据库中的会话要简单得多。任何时候只能有一个进程在一个会话之中，其他进程必须等待当前会话中的进程结束。因此同意时刻日志最多只记录一次会话。

xv6不允许并发会话，目的是为了避免下面几种问题。假设会话 X 把一个对 i节点的修改写入了会话中。并发的会话 Y从同一块中读出了另一个i 节点，更新了它，把 i 节点块写入了日志并且提交。这是一场灾难：Y 的提交导致被 X 修改过的 i 节点块被写入磁盘，而 X 此时并没有提交它的修改。如果这时候发生崩溃会使得 X 的修改只应用了一部分而不是全部，从而打破会话是原子的这一性质。有一些复杂的办法可以解决这样的问题，xv6通过不允许并行的会话来消除这个问题。

xv6允许只读的系统调用能够在一次会话中并发执行。I 节点锁会使得会话对只读系统调用看上去是原子性的。

xv6 使用固定量的磁盘空间来保存日志。系统调用写入日志的块的总大小不能大于日志的总大小。对于大多数系统调用来说这都不是个问题，但是其中两个可能会写大量的块：write 和 unlink。一个大文件的写可能会写很多的数据块、位图快、以及i 节点块。移除个大文件的链接可能会写很多的位图块以及一个 i 节点。XV6的写系统调用将大的写操作拆分成几个小的写操作，使得它们能放入日志中。unlink 不会导致问题因为实际上 xv6 只使用一个位图块。

代码：日志

